<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crate Opening Elimination</title>
    <style>
        :root {
            --base-scale: min(1, max(0.5, sqrt((100vw * 100vh) / (1920 * 1080))));
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: calc(10px * var(--base-scale));
            color: white;
            overflow-x: hidden;
            font-size: calc(16px * var(--base-scale));
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 calc(5px * var(--base-scale));
        }

        h1 {
            text-align: center;
            margin-bottom: calc(20px * var(--base-scale));
            font-size: calc(2.5em * var(--base-scale));
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .setup-section {
            background: rgba(255,255,255,0.1);
            padding: calc(15px * var(--base-scale));
            border-radius: calc(10px * var(--base-scale));
            margin-bottom: calc(20px * var(--base-scale));
            backdrop-filter: blur(10px);
        }

        .setup-section label {
            display: block;
            margin-bottom: calc(8px * var(--base-scale));
            font-size: calc(1.2em * var(--base-scale));
        }

        .setup-section input {
            width: min(calc(200px * var(--base-scale)), 80%);
            padding: calc(8px * var(--base-scale));
            font-size: calc(1em * var(--base-scale));
            border-radius: calc(5px * var(--base-scale));
            border: none;
            margin-right: calc(10px * var(--base-scale));
        }

        .setup-section button {
            padding: calc(8px * var(--base-scale)) calc(16px * var(--base-scale));
            font-size: calc(1em * var(--base-scale));
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: calc(5px * var(--base-scale));
            cursor: pointer;
            transition: background 0.3s;
        }

        .setup-section button:hover {
            background: #45a049;
        }

        .random-bet-button {
            background: #9C27B0;
            font-size: calc(1.2em * var(--base-scale));
            padding: calc(8px * var(--base-scale)) calc(12px * var(--base-scale));
            margin-left: calc(10px * var(--base-scale));
        }

        .random-bet-button:hover {
            background: #7B1FA2;
        }

        #totalBetDisplay {
            margin-top: calc(10px * var(--base-scale));
            font-size: calc(1.1em * var(--base-scale));
            color: #FFD700;
        }

        .bet-range-inputs {
            margin-top: calc(10px * var(--base-scale));
            display: none;
        }

        .bet-range-inputs.active {
            display: block;
        }

        .crate-section {
            background: rgba(0,0,0,0.3);
            padding: calc(20px * var(--base-scale)) calc(5px * var(--base-scale));
            border-radius: calc(15px * var(--base-scale));
            margin-bottom: calc(20px * var(--base-scale));
            text-align: center;
            overflow: visible;
        }

        .crates {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: calc(max(min(1vw, 10px), 6px) * var(--base-scale));
            margin-bottom: calc(20px * var(--base-scale));
            flex-wrap: nowrap;
            overflow: visible;
            padding: calc(5px * var(--base-scale)) calc(2px * var(--base-scale));
            width: 100%;
        }

        .crate {
            width: calc((100vw - 40px - (10 * min(1vw, 8px))) / 11);
            height: calc((100vw - 40px - (10 * min(1vw, 8px))) / 11);
            max-width: calc(80px * var(--base-scale));
            max-height: calc(80px * var(--base-scale));
            min-width: calc(30px * var(--base-scale));
            min-height: calc(30px * var(--base-scale));
            flex-shrink: 0;
            flex-grow: 0;
            border-radius: 15%;
            border: calc(3px * var(--base-scale)) solid rgba(255,255,255,0.5);
            outline: calc(2px * var(--base-scale)) solid rgba(0,0,0,0.4);
            outline-offset: calc(-1px * var(--base-scale));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            transition: background 0.05s linear, border-color 0.05s linear;
            box-sizing: border-box;
            font-size: calc(16px * var(--base-scale));
        }

        .crate.middle {
            border: calc(4px * var(--base-scale)) solid #FFD700;
            outline: calc(2px * var(--base-scale)) solid rgba(255,215,0,0.6);
            box-shadow: 0 0 calc(15px * var(--base-scale)) #FFD700;
            transform: scale(1.05);
        }

        .crate-number {
            font-size: calc(0.5em * var(--base-scale));
            margin-top: calc(2px * var(--base-scale));
            line-height: 1;
        }

        /* Portrait mode optimization (9:16 and similar) */
        @media (max-aspect-ratio: 9/16) {
            .crate-section {
                padding: 10px 2px;
            }
            
            .crates {
                gap: min(0.5vw, 4px);
                padding: 3px 1px;
            }
            
            .crate {
                width: calc((100vw - 20px - (10 * min(0.5vw, 4px))) / 11);
                height: calc((100vw - 20px - (10 * min(0.5vw, 4px))) / 11);
                min-width: 25px;
                min-height: 25px;
                border-radius: 6px;
                border-width: 2px;
            }
            
            .crate.middle {
                border-width: 2px;
                transform: scale(1.03);
                box-shadow: 0 0 10px #FFD700;
            }
            
            .crate-number {
                font-size: 0.45em;
            }
        }

        @media (max-width: 768px) {
            .crate {
                border-width: 2px;
                border-radius: 6px;
            }
            .crate.middle {
                border-width: 2px;
                transform: scale(1.03);
            }
            .crate-number {
                font-size: 0.45em;
            }
        }

        @media (max-width: 480px) {
            .crate {
                border-width: 1px;
                border-radius: 4px;
            }
            .crate.middle {
                border-width: 2px;
            }
            .crate-number {
                font-size: 0.4em;
            }
        }

        .spin-button {
            padding: clamp(10px, 2vw, 15px) clamp(20px, 4vw, 40px);
            font-size: clamp(1em, 2.5vw, 1.3em);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .spin-button:hover {
            transform: scale(1.05);
        }

        .spin-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .result-section {
            text-align: center;
            margin: 30px 0;
        }

        .result-display {
            display: inline-block;
            padding: 30px;
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            min-width: 300px;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .result-crate {
            width: 120px;
            height: 120px;
            margin: 20px auto;
            border-radius: 15px;
            border: 4px solid white;
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .result-text {
            font-size: 1.5em;
            margin: 10px 0;
        }

        .bet-checker-section {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .bet-checker-section h3 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .bet-checker-section input {
            width: min(150px, 60%);
            padding: 8px;
            font-size: 1em;
            border-radius: 5px;
            border: none;
            margin-right: 10px;
        }

        .bet-checker-section button {
            padding: 8px 16px;
            font-size: 1em;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .bet-checker-section button:hover {
            background: #1976D2;
        }

        #betCheckerResult {
            margin-top: 10px;
            font-size: 1.1em;
            color: #FFD700;
        }

        .players-section {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .players-section h2 {
            margin-bottom: 20px;
            text-align: center;
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
        }

        .player-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .player-card.eliminated {
            opacity: 0.5;
            background: rgba(255,0,0,0.2);
        }

        .player-card.eliminated .player-number {
            text-decoration: line-through;
        }

        .player-number {
            font-size: 1.5em;
            font-weight: bold;
        }

        .player-status {
            font-size: 0.9em;
            margin-top: 5px;
            color: #4CAF50;
        }

        .player-card.eliminated .player-status {
            color: #f44336;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }

        .modal-content h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .modal-content p {
            font-size: 1.3em;
            margin-bottom: 30px;
            white-space: pre-line;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .modal-button {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: bold;
        }

        .modal-button.primary {
            background: #4CAF50;
            color: white;
        }

        .modal-button:hover {
            transform: scale(1.05);
        }

        .save-section {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
        }

        .save-section button {
            padding: 12px 30px;
            font-size: 1.1em;
            margin: 0 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .save-button {
            background: #2196F3;
            color: white;
        }

        .save-button:hover {
            background: #1976D2;
        }

        .load-button {
            background: #FF9800;
            color: white;
        }

        .load-button:hover {
            background: #F57C00;
        }

        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÅ Crate Opening Elimination</h1>

        <div class="setup-section">
            <label>Number of Players:</label>
            <input type="number" id="playerCount" min="2" max="500" value="10">
            <br><br>
            <label>Bet Amount Per Player (optional - leave empty for no money):</label>
            <input type="number" id="betAmount" min="0" step="1" placeholder="Enter whole number">
            <button class="random-bet-button" onclick="toggleBetRange()" title="Random Bet Amounts">üé≤</button>
            <div class="bet-range-inputs" id="betRangeInputs">
                <br>
                <label>Min Bet:</label>
                <input type="number" id="minBet" min="0" step="1" value="1">
                <label>Max Bet:</label>
                <input type="number" id="maxBet" min="0" step="1" value="100">
            </div>
            <div id="totalBetDisplay"></div>
            <br>
            <button onclick="initGame()">Start Game</button>
        </div>

        <div class="crate-section">
            <div class="crates" id="cratesDisplay"></div>
            <button class="spin-button" id="spinButton" onclick="spin()" disabled>üé≤ Spin</button>
        </div>

        <div class="result-section" id="resultSection" style="display: none;">
            <div class="result-display">
                <div class="result-crate" id="resultCrate"></div>
                <div class="result-text" id="resultText"></div>
            </div>
        </div>

        <div class="bet-checker-section" id="betCheckerSection" style="display: none;">
            <h3>Check Player Bet Amount</h3>
            <input type="number" id="playerCheckNumber" min="1" placeholder="Player #">
            <button onclick="checkPlayerBet()">Check</button>
            <div id="betCheckerResult"></div>
        </div>

        <div class="players-section" id="playersSection" style="display: none;">
            <h2>Players Status</h2>
            <div class="players-grid" id="playersGrid"></div>
        </div>

        <div class="save-section">
            <button class="save-button" onclick="saveGame()">üíæ Save JSON File</button>
            <button class="load-button" onclick="document.getElementById('fileInput').click()">üìÇ Load JSON File</button>
            <input type="file" id="fileInput" accept=".json" onchange="loadGame(event)">
        </div>
    </div>

    <div class="modal" id="winnerModal">
        <div class="modal-content">
            <h2>üéâ Winner! üéâ</h2>
            <p id="winnerText"></p>
            <div class="modal-buttons">
                <button class="modal-button primary" onclick="playAgain()">Play Again!</button>
            </div>
        </div>
    </div>

    <script>
        const rainbowKeyframes = [
            { r: 255, g: 0, b: 0 },      // #FF0000 Red
            { r: 255, g: 140, b: 0 },    // #FF8C00 Orange
            { r: 255, g: 255, b: 0 },    // #FFFF00 Yellow
            { r: 0, g: 255, b: 0 },      // #00FF00 Green
            { r: 0, g: 0, b: 255 },      // #0000FF Blue
            { r: 128, g: 0, b: 255 }     // #8000FF Purple
        ];

        let gameState = {
            totalPlayers: 0,
            players: [],
            isGameActive: false,
            playerColors: [],
            betAmount: 0,
            totalBet: 0,
            hasBet: false,
            randomBets: false
        };

        function toggleBetRange() {
            const betRangeInputs = document.getElementById('betRangeInputs');
            betRangeInputs.classList.toggle('active');
        }

        function checkPlayerBet() {
            const playerNum = parseInt(document.getElementById('playerCheckNumber').value);
            const resultDiv = document.getElementById('betCheckerResult');
            
            if (!playerNum || playerNum < 1 || playerNum > gameState.totalPlayers) {
                resultDiv.textContent = 'Invalid player number!';
                return;
            }
            
            const player = gameState.players.find(p => p.number === playerNum);
            if (player && gameState.hasBet) {
                resultDiv.textContent = `Player ${playerNum} bet: $${player.betAmount}`;
            } else {
                resultDiv.textContent = 'No bet information available';
            }
        }

        function generateRainbowColors(count) {
            const colors = [];
            const segments = rainbowKeyframes.length - 1;
            
            for (let i = 0; i < count; i++) {
                const position = i / (count - 1);
                const scaledPosition = position * segments;
                const segmentIndex = Math.floor(scaledPosition);
                const segmentProgress = scaledPosition - segmentIndex;
                
                const startColor = rainbowKeyframes[Math.min(segmentIndex, segments - 1)];
                const endColor = rainbowKeyframes[Math.min(segmentIndex + 1, segments)];
                
                const r = Math.round(startColor.r + (endColor.r - startColor.r) * segmentProgress);
                const g = Math.round(startColor.g + (endColor.g - startColor.g) * segmentProgress);
                const b = Math.round(startColor.b + (endColor.b - startColor.b) * segmentProgress);
                
                colors.push(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`);
            }
            
            return colors;
        }

        function initGame() {
            const count = parseInt(document.getElementById('playerCount').value);
            if (count < 2 || count > 500) {
                alert('Please enter a number between 2 and 500');
                return;
            }

            const betInput = document.getElementById('betAmount').value;
            const betRangeActive = document.getElementById('betRangeInputs').classList.contains('active');
            
            let betPerPlayer = 0;
            let totalBet = 0;
            let randomBets = false;

            gameState.totalPlayers = count;
            gameState.players = [];
            gameState.isGameActive = true;
            gameState.playerColors = generateRainbowColors(count);

            if (betRangeActive) {
                // Random bets mode
                const minBet = parseInt(document.getElementById('minBet').value) || 1;
                const maxBet = parseInt(document.getElementById('maxBet').value) || 100;
                randomBets = true;
                
                for (let i = 1; i <= count; i++) {
                    const playerBet = Math.floor(Math.random() * (maxBet - minBet + 1)) + minBet;
                    totalBet += playerBet;
                    gameState.players.push({
                        number: i,
                        eliminated: false,
                        color: gameState.playerColors[i - 1],
                        betAmount: playerBet
                    });
                }
            } else if (betInput) {
                // Fixed bet per player
                betPerPlayer = parseInt(betInput);
                totalBet = betPerPlayer * count;
                
                for (let i = 1; i <= count; i++) {
                    gameState.players.push({
                        number: i,
                        eliminated: false,
                        color: gameState.playerColors[i - 1],
                        betAmount: betPerPlayer
                    });
                }
            } else {
                // No bets
                for (let i = 1; i <= count; i++) {
                    gameState.players.push({
                        number: i,
                        eliminated: false,
                        color: gameState.playerColors[i - 1],
                        betAmount: 0
                    });
                }
            }

            gameState.betAmount = betPerPlayer;
            gameState.totalBet = totalBet;
            gameState.hasBet = totalBet > 0;
            gameState.randomBets = randomBets;

            if (gameState.hasBet) {
                document.getElementById('totalBetDisplay').textContent = 
                    randomBets ? `Total Prize Pool: $${totalBet}` : `Total Prize Pool: $${betPerPlayer} √ó ${count} players = $${totalBet}`;
                document.getElementById('betCheckerSection').style.display = randomBets ? 'block' : 'none';
            } else {
                document.getElementById('totalBetDisplay').textContent = '';
                document.getElementById('betCheckerSection').style.display = 'none';
            }

            renderCrates();
            renderPlayers();
            document.getElementById('spinButton').disabled = false;
            document.getElementById('playersSection').style.display = 'block';
            document.getElementById('resultSection').style.display = 'none';
        }

        function renderCrates(crateData = null) {
            const cratesDisplay = document.getElementById('cratesDisplay');
            cratesDisplay.innerHTML = '';

            let displayData;
            if (crateData) {
                displayData = crateData;
            } else {
                displayData = gameState.players.length > 0 ? 
                    gameState.players.slice(0, Math.min(11, gameState.players.length)) :
                    Array(11).fill(null).map((_, i) => ({ number: i + 1, color: '#FF0000' }));
            }

            for (let i = 0; i < 11; i++) {
                const crate = document.createElement('div');
                crate.className = 'crate';
                if (i === 5) {
                    crate.classList.add('middle');
                }
                
                const player = displayData[i] || displayData[0];
                crate.style.background = player.color;
                crate.innerHTML = `<div class="crate-number">#${player.number}</div>`;
                cratesDisplay.appendChild(crate);
            }
        }

        function renderPlayers() {
            const playersGrid = document.getElementById('playersGrid');
            playersGrid.innerHTML = '';

            gameState.players.forEach(player => {
                const card = document.createElement('div');
                card.className = `player-card ${player.eliminated ? 'eliminated' : ''}`;
                card.style.borderColor = player.color;
                card.innerHTML = `
                    <div class="player-number" style="color: ${player.color}">Player ${player.number}</div>
                    <div class="player-status">${player.eliminated ? 'Eliminated' : 'Active'}</div>
                `;
                playersGrid.appendChild(card);
            });
        }

        function spin() {
            if (!gameState.isGameActive) return;

            const activePlayers = gameState.players.filter(p => !p.eliminated);
            if (activePlayers.length === 0) return;

            document.getElementById('spinButton').disabled = true;

            // Generate random sequence of active players
            const sequence = [];
            for (let i = 0; i < 100; i++) {
                const randomPlayer = activePlayers[Math.floor(Math.random() * activePlayers.length)];
                sequence.push(randomPlayer);
            }

            let eliminatedPlayer = null;
            let startTime = null;
            const totalDuration = 3000; // 3 seconds total
            let lastFrameIndex = -1;
            let hasFinished = false;
            
            // Pick the final stopping position ahead of time
            const finalFrameIndex = 60;

            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;

                // Calculate progress based on elapsed time (0 to 1)
                let progress = Math.min(elapsed / totalDuration, 1);
                
                // Ease out with power of 5
                const easeOut = 1 - Math.pow(1 - progress, 5);
                
                // Calculate position - multiply easeOut by (finalFrame - 0.5) 
                // This ensures we never quite reach the next frame
                const position = easeOut * (finalFrameIndex - 0.5);
                
                const frameIndex = Math.floor(position);

                // Only update display when we move to a new frame AND haven't reached final frame
                if (frameIndex !== lastFrameIndex && !hasFinished && frameIndex < finalFrameIndex) {
                    lastFrameIndex = frameIndex;
                    
                    // Shift the display
                    const displaySlice = [];
                    for (let i = 0; i < 11; i++) {
                        const seqIndex = (frameIndex + i) % sequence.length;
                        displaySlice.push(sequence[seqIndex]);
                    }
                    
                    // Store the middle player
                    eliminatedPlayer = displaySlice[5];
                    renderCrates(displaySlice);
                }

                // When we reach the final frame, lock in and stop
                if (frameIndex >= finalFrameIndex - 1 && !hasFinished) {
                    hasFinished = true;
                    
                    // Render final position
                    const finalDisplaySlice = [];
                    for (let i = 0; i < 11; i++) {
                        const seqIndex = (finalFrameIndex + i) % sequence.length;
                        finalDisplaySlice.push(sequence[seqIndex]);
                    }
                    eliminatedPlayer = finalDisplaySlice[5];
                    renderCrates(finalDisplaySlice);
                    
                    // Animation complete
                    eliminatedPlayer.eliminated = true;

                    // Show result after a brief pause
                    setTimeout(() => {
                        const resultSection = document.getElementById('resultSection');
                        const resultCrate = document.getElementById('resultCrate');
                        const resultText = document.getElementById('resultText');

                        resultCrate.style.background = eliminatedPlayer.color;
                        resultText.innerHTML = `Player ${eliminatedPlayer.number}<br>Eliminated!`;
                        resultSection.style.display = 'block';

                        renderPlayers();

                        // Check if only one player remains
                        const remainingPlayers = gameState.players.filter(p => !p.eliminated);
                        if (remainingPlayers.length === 1) {
                            setTimeout(() => {
                                showWinner(remainingPlayers[0]);
                            }, 1000);
                        } else {
                            setTimeout(() => {
                                document.getElementById('spinButton').disabled = false;
                            }, 1500);
                        }
                    }, 300);
                    
                    return;
                }

                if (!hasFinished) {
                    requestAnimationFrame(animate);
                }
            }

            requestAnimationFrame(animate);
        }

        function showWinner(winner) {
            let winnerMessage = `Player ${winner.number} is the winner!`;
            
            if (gameState.hasBet) {
                // Prize pool is just the total bet amount (no multipliers)
                const prize = gameState.totalBet;
                
                winnerMessage += `\n\nTotal Prize Pool: $${prize.toFixed(2)}\nYou won: $${prize.toFixed(2)}!`;
            }
            
            document.getElementById('winnerText').textContent = winnerMessage;
            document.getElementById('winnerModal').classList.add('active');
            gameState.isGameActive = false;
        }

        function playAgain() {
            document.getElementById('winnerModal').classList.remove('active');
            initGame();
        }

        function saveGame() {
            const filename = prompt('Enter filename for JSON file:', 'game-progress');
            if (!filename) return;

            const data = JSON.stringify(gameState, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename.endsWith('.json') ? filename : `${filename}.json`;
            
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        function loadGame(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedState = JSON.parse(e.target.result);
                    gameState = loadedState;
                    document.getElementById('playerCount').value = gameState.totalPlayers;
                    renderCrates();
                    renderPlayers();
                    document.getElementById('playersSection').style.display = 'block';
                    document.getElementById('spinButton').disabled = !gameState.isGameActive;
                    
                    const remainingPlayers = gameState.players.filter(p => !p.eliminated);
                    if (remainingPlayers.length === 1) {
                        showWinner(remainingPlayers[0]);
                    }
                } catch (err) {
                    alert('Error loading file: Invalid JSON format');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }
    </script>
</body>
</html>
